warning! formatting, wordings and grammar mistake ahead
<constructor>(const string&in path)
Load the specified PNG image into a CFileImage object. The string argument represent the path of your image.
the string argument is the path to the png file to which you want to link your CFileImage object to.
It create a CFileImage object that point to the file in the specified path.
usage example : CFileImage@ myImage = CFileImage("Maps/MyModName/"+ map_name + ".png");


<constructor>(int width, int height, bool has_alpha)
Construct and load a CFileImage object with a specified width, height and specify if the resulting image has alpha (? fact check this).
CFileImage@ myImage = CFileImage(100,75,true); this could be used to create a png file with 100 pixels width and 75 pixel height that has the alpha channel enabled.

/*this method is purely speculation on my part, haven't tested it yet
bool isLoaded()
return a bool value to know weither a image has been loaded into a CFileImage object.
Return true when there's in fact a image loaded into the CFileImage Object
Return false when there's not a image loaded into the CFileImage Object
usage : CFileImage@ myimage;
if(myimage.isLoaded()){[...]}
*/

/*this method is purely speculation on my part, haven't tested it yet
void ResetPixel()
clear the currently selected pixel from his value. (probably put the pixel value to 0)
*/

/*this method is purely speculation on my part, haven't tested it yet
void canRead()
Check whether or not the loaded file can be read.
return false if it cannot be read
return true if it can be read
*/

/*this method is purely speculation on my part, haven't tested it yet
bool nextPixel()
probably something similar to objects with iterator pattern :
Returns true if the CFileImage object has another token in its input.
usage : CFileImage@ myImage = CFileImage("potatoes.png");
while(myImage.nextPixel())
{
// do stuff
SColor currentPixel = myImage.readPixel();
}
*/

/*this method is purely speculation on my part, haven't tested it yet
SColor readPixel()
same thing as readPixel(uint8&out a, uint8&out r, uint8&out g, uint8&out b) but without verification of if the pixel could be read ???
*/
/*this method is purely speculation on my part, haven't tested it yet
readPixel(uint8&out a, uint8&out r, uint8&out g, uint8&out b)
Read the current pixel color value using predefined u8 variable.
Put in argument of the function the variable that you want the function to modify.
usage : 
    if (myImage.isLoaded())
		{
			while(myImage.nextPixel() && !done)
      {
          int index = image.getPixelOffset()*4;
          if(index >= map_size)
          {
              done = true;
              break;
          }
          u8 a;
          u8 r;
          u8 g;
          u8 b;
          save_image.readPixel(a, r, g, b);
      }
    }
*/
Vec2f getPixelPosition()
void setPixelPosition(Vec2f pos)
int getPixelOffset()
void setPixelOffset(int pos) //this function would be important to document
int getWidth()
int getHeight()
int getSizeInPixels()
void setFilename(const string&in filename, ImageFileBase base)
void Save()
void setPixel(uint8 a, uint8 r, uint8 g, uint8 b)
void setPixelAndAdvance(uint8 a, uint8 r, uint8 g, uint8 b)
void setPixel(SColor col)
void setPixelAndAdvance(SColor col)
void setPixelAtPosition(uint x, uint y, SColor col, bool blend_alpha)

related enums :
IMAGE_FILENAME_BASE_MAPS it serve to specify ????????
IMAGE_FILENAME_BASE_CACHE it serve to specify ????????

Variable : 
CFileImage::bool silent_errors
